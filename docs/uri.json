{
  "folders": [
    "design-survey",
    "customize-question-types"
  ],
  "rename": {
    "design-survey-question-titles": "design-survey-configure-question-titles",
    "design-survey-conditional-display": "design-survey-conditional-logic",
    "design-survey-predefine-answers": "design-survey-pre-populate-form-fields",
    "localization": "survey-localization",
    "handle-survey-results-access": "access-and-modify-survey-results",
    "handle-survey-results-store": "how-to-store-survey-results",
    "handle-survey-results-continue-incomplete": "how-to-save-and-restore-incomplete-survey"
  },
  "classRename": {
    "surveymodel": "survey-data-model",
    "pagemodel": "page-model",
    "popupsurveymodel": "pop-up-survey-model",
    "questiontextmodel": "text-entry-question-model",
    "questioncheckboxmodel": "checkbox-question-model",
    "questionrankingmodel": "ranking-question-model",
    "questionradiogroupmodel": "radio-button-question-model",
    "questiondropdownmodel": "dropdown-menu-model",
    "questiontagboxmodel": "dropdown-tag-box-model",
    "questioncommentmodel": "comment-field-model",
    "questionratingmodel": "rating-scale-question-model",
    "questionimagepickermodel": "image-picker-question-model",
    "questionbooleanmodel": "boolean-question-model",
    "questionimagemodel": "add-image-to-survey",
    "questionhtmlmodel": "add-custom-html-to-survey",
    "questionsignaturepadmodel": "signature-pad-model",
    "questionexpressionmodel": "expression-model",
    "questionfilemodel": "file-model",
    "questionmatrixmodel": "matrix-table-question-model",
    "panelmodel": "panel-model",
    "questionpaneldynamicmodel": "dynamic-panel-model",
    "questionmultipletextmodel": "multiple-text-entry-question-model",
    "questionmatrixdynamicmodel": "dynamic-matrix-table-question-model",
    "questionmatrixdropdownmodel": "matrix-table-with-dropdown-list"
  }
}

The handler approach seems best in your situation. Let me provide a complete implementation for the handler solution that will ensure consistent logout behavior for both Plan Member and Plan Admin paths.

Here's a comprehensive `LogoutHandler` that will intercept any logout request and ensure complete session cleanup:

```csharp
public class LogoutCookieModule : IHttpModule
{
    private static readonly ILog log = LogManager.GetLogger(typeof(LogoutCookieModule));

    public void Init(HttpApplication context)
    {
        context.EndRequest += OnEndRequest;
    }

    private void OnEndRequest(object sender, EventArgs e)
    {
        var app = sender as HttpApplication;
        if (app == null) return;

        var context = app.Context;
        var request = context.Request;
        var response = context.Response;

        // Check if any logout URL is being accessed
        if (request.Path.ToLowerInvariant().Contains("/account/logoff") ||
            request.Path.ToLowerInvariant().Contains("/account/logout"))
        {
            log.Info("Logout detected - clearing all auth cookies");
            
            // Clear all authentication cookies
            ClearAllAuthCookies(context);
            
            // Clear session
            if (context.Session != null)
            {
                context.Session.Clear();
                context.Session.Abandon();
            }
            
            // Sign out of Auth0 via OWIN
            try
            {
                var owinContext = context.GetOwinContext();
                if (owinContext != null)
                {
                    owinContext.Authentication.SignOut(CookieAuthenticationDefaults.AuthenticationType);
                    owinContext.Authentication.SignOut("Auth0");
                }
            }
            catch (Exception ex)
            {
                log.Error("Error signing out of Auth0", ex);
            }
        }
    }
    
    private void ClearAllAuthCookies(HttpContext context)
    {
        // Clear all authentication-related cookies
        string[] cookiesToClear = new string[] {
            FormsAuthentication.FormsCookieName,
            "SessionTimestamp",
            EQ.EquitableHealth.Web.Constants.CookieNames.TimeoutIndicator,
            EQ.EquitableHealth.Web.Constants.CookieNames.Context,
            EQ.EquitableHealth.Web.Constants.CookieNames.Auth,
            EQ.EquitableHealth.Web.Constants.CookieNames.LegacyTimeoutIndicator,
            EQ.EquitableHealth.Web.Constants.CookieNames.PmCertId
        };
        
        foreach (string cookieName in cookiesToClear)
        {
            var cookie = new HttpCookie(cookieName)
            {
                Expires = DateTime.Now.AddDays(-1),
                Domain = FormsAuthentication.CookieDomain,
                Secure = FormsAuthentication.RequireSSL,
                HttpOnly = true,
                SameSite = SameSiteMode.None
            };
            
            context.Response.Cookies.Add(cookie);
        }
        
        // Also clear ASP.NET auth cookies
        foreach (string cookieName in context.Request.Cookies.AllKeys)
        {
            if (cookieName.StartsWith(".AspNet"))
            {
                var cookie = new HttpCookie(cookieName)
                {
                    Expires = DateTime.Now.AddDays(-1),
                    Domain = FormsAuthentication.CookieDomain
                };
                context.Response.Cookies.Add(cookie);
            }
        }
    }

    public void Dispose() { }
}
```

Then register this module in your web.config:

```xml
<add name="LogoutCookieModule" type="Equitable.EquitableHealth.Web.LogoutCookieModule, Equitable.EquitableHealth.Web" />
```

This approach will:

1. Intercept any logout request (whether it's `/Account/Logout` or `/Account/LogOff`)
2. Clear all authentication cookies consistently
3. Clear session data
4. Sign out of Auth0

The key advantage of this handler approach is that it works regardless of which code path initiated the logout - it will ensure a complete logout even if the VB code only clears some cookies.

No other changes should be needed as this handler will run for every request, looking for logout URLs and handling them consistently.
